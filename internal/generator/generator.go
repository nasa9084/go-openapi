package generator

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"strconv"
	"strings"

	"github.com/nasa9084/go-openapi/internal/pool"
)

const packageName = "openapi"

var showSrc bool

func init() {
	flag.BoolVar(&showSrc, "show-src", false, "")
}

type Generator struct {
	name    string
	imports imports
	body    *bytes.Buffer

	showSource bool
}

type import_ struct {
	name string
	path string
}

type imports struct {
	stdpkg     []import_
	thirdparty []import_
}

func New(name string) *Generator {
	return &Generator{
		name: name,
		body: new(bytes.Buffer),

		showSource: showSrc,
	}
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(g.body, format, args...)
}

func (g *Generator) Import(name, path string) {
	if strings.ContainsRune(strings.Split(path, "/")[0], '.') {
		g.imports.thirdparty = append(g.imports.thirdparty, import_{
			name: name,
			path: path,
		})

		return
	}

	g.imports.stdpkg = append(g.imports.stdpkg, import_{
		name: name,
		path: path,
	})
}

var WriteFile = ioutil.WriteFile

func (g *Generator) Save(filepath string) error {
	buf := pool.GetBytesBuffer()
	defer pool.Put(buf)

	fmt.Fprintf(buf, "// Code generated by %s. DO NOT EDIT.", g.name)
	fmt.Fprintf(buf, "\n\npackage %s", packageName)
	fmt.Fprintf(buf, "\n%s", g.imports.String())
	fmt.Fprintf(buf, "\n%s", g.body.String())

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("error on formatting source code: %v", err)
		printSource(buf.Bytes())

		return err
	}

	if g.showSource {
		printSource(src)
	}

	return WriteFile(filepath, src, 0644)
}

func (imports imports) String() string {
	if len(imports.stdpkg) == 0 && len(imports.thirdparty) == 0 {
		return ""
	}

	if len(imports.stdpkg)+len(imports.thirdparty) == 1 {
		if len(imports.stdpkg) == 1 {
			return imports.stdpkg[0].String()
		}

		return imports.thirdparty[0].String()
	}

	buf := pool.GetBytesBuffer()
	defer pool.Put(buf)

	outf := func(format string, args ...interface{}) {
		fmt.Fprintf(buf, format, args...)
	}

	outf("\nimport (")

	for _, i := range imports.stdpkg {
		outf("\n%s", i.String())
	}

	if len(imports.stdpkg) != 0 && len(imports.thirdparty) != 0 {
		outf("\n")
	}

	for _, i := range imports.thirdparty {
		outf("\n%s", i.String())
	}

	outf("\n)")

	return buf.String()
}

func (i import_) String() string {
	if i.name != "" {
		return i.name + " " + strconv.Quote(i.path)
	}

	return strconv.Quote(i.path)
}

func printSource(src []byte) {
	log.Print("=== SOURCE ===")

	scanner := bufio.NewScanner(bytes.NewReader(src))
	for scanner.Scan() {
		log.Print(scanner.Text())
	}

	log.Print("=== SOURCE ===")
}
