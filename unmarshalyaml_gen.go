// Code generated by mkunmarshalyaml.go. DO NOT EDIT.

package openapi

import (
	"bytes"
	"errors"
	"net/url"
	"regexp"
	"strings"

	yaml "github.com/goccy/go-yaml"
)

func q(b []byte) []byte {
	if !bytes.HasPrefix(b, []byte("|")) {
		if bytes.ContainsRune(b, '\'') {
			return append([]byte{'"'}, append(b, '"')...)
		}
		return append([]byte{'\''}, append(b, '\'')...)
	}
	return b
}

func (v *OpenAPI) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	openapiBytes, ok := proxy["openapi"]
	if !ok {
		return ErrRequired("openapi")
	}
	var openapiVal string
	if err := yaml.Unmarshal(q(openapiBytes), &openapiVal); err != nil {
		return err
	}
	v.openapi = openapiVal
	delete(proxy, `openapi`)

	if !isValidSemVer(v.openapi) {
		return errors.New(`"openapi" field must be a valid semantic version but not`)
	}

	infoBytes, ok := proxy["info"]
	if !ok {
		return ErrRequired("info")
	}
	var infoVal Info
	if err := yaml.Unmarshal(infoBytes, &infoVal); err != nil {
		return err
	}
	v.info = &infoVal
	delete(proxy, `info`)

	if serversBytes, ok := proxy["servers"]; ok {
		var serversVal []*Server
		if err := yaml.Unmarshal(serversBytes, &serversVal); err != nil {
			return err
		}
		v.servers = serversVal
		delete(proxy, `servers`)
	}

	pathsBytes, ok := proxy["paths"]
	if !ok {
		return ErrRequired("paths")
	}
	var pathsVal Paths
	if err := yaml.Unmarshal(pathsBytes, &pathsVal); err != nil {
		return err
	}
	v.paths = &pathsVal
	delete(proxy, `paths`)

	if componentsBytes, ok := proxy["components"]; ok {
		var componentsVal Components
		if err := yaml.Unmarshal(componentsBytes, &componentsVal); err != nil {
			return err
		}
		v.components = &componentsVal
		delete(proxy, `components`)
	}

	if securityBytes, ok := proxy["security"]; ok {
		var securityVal []*SecurityRequirement
		if err := yaml.Unmarshal(securityBytes, &securityVal); err != nil {
			return err
		}
		v.security = securityVal
		delete(proxy, `security`)
	}

	if tagsBytes, ok := proxy["tags"]; ok {
		var tagsVal []*Tag
		if err := yaml.Unmarshal(tagsBytes, &tagsVal); err != nil {
			return err
		}
		v.tags = tagsVal
		delete(proxy, `tags`)
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
		delete(proxy, `externalDocs`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	v.setRoot(v)
	return nil
}

func (v *Info) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	titleBytes, ok := proxy["title"]
	if !ok {
		return ErrRequired("title")
	}
	var titleVal string
	if err := yaml.Unmarshal(q(titleBytes), &titleVal); err != nil {
		return err
	}
	v.title = titleVal
	delete(proxy, `title`)

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if termsOfServiceBytes, ok := proxy["termsOfService"]; ok {
		var termsOfServiceVal string
		if err := yaml.Unmarshal(q(termsOfServiceBytes), &termsOfServiceVal); err != nil {
			return err
		}
		v.termsOfService = termsOfServiceVal
		delete(proxy, `termsOfService`)
	}

	if v.termsOfService != "" {
		if _, err := url.ParseRequestURI(v.termsOfService); err != nil {
			return err
		}
	}

	if contactBytes, ok := proxy["contact"]; ok {
		var contactVal Contact
		if err := yaml.Unmarshal(contactBytes, &contactVal); err != nil {
			return err
		}
		v.contact = &contactVal
		delete(proxy, `contact`)
	}

	if licenseBytes, ok := proxy["license"]; ok {
		var licenseVal License
		if err := yaml.Unmarshal(licenseBytes, &licenseVal); err != nil {
			return err
		}
		v.license = &licenseVal
		delete(proxy, `license`)
	}

	versionBytes, ok := proxy["version"]
	if !ok {
		return ErrRequired("version")
	}
	var versionVal string
	if err := yaml.Unmarshal(q(versionBytes), &versionVal); err != nil {
		return err
	}
	v.version = versionVal
	delete(proxy, `version`)
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Contact) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		var nameVal string
		if err := yaml.Unmarshal(q(nameBytes), &nameVal); err != nil {
			return err
		}
		v.name = nameVal
		delete(proxy, `name`)
	}

	if urlBytes, ok := proxy["url"]; ok {
		var urlVal string
		if err := yaml.Unmarshal(q(urlBytes), &urlVal); err != nil {
			return err
		}
		v.url = urlVal
		delete(proxy, `url`)
	}

	if v.url != "" {
		if _, err := url.ParseRequestURI(v.url); err != nil {
			return err
		}
	}

	if emailBytes, ok := proxy["email"]; ok {
		var emailVal string
		if err := yaml.Unmarshal(q(emailBytes), &emailVal); err != nil {
			return err
		}
		v.email = emailVal
		delete(proxy, `email`)
	}

	if v.email != "" {

		if v.email != "" && !emailRegexp.MatchString(v.email) {
			return errors.New(`"email" field must be an email address`)
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *License) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return ErrRequired("name")
	}
	var nameVal string
	if err := yaml.Unmarshal(q(nameBytes), &nameVal); err != nil {
		return err
	}
	v.name = nameVal
	delete(proxy, `name`)

	if urlBytes, ok := proxy["url"]; ok {
		var urlVal string
		if err := yaml.Unmarshal(q(urlBytes), &urlVal); err != nil {
			return err
		}
		v.url = urlVal
		delete(proxy, `url`)
	}

	if v.url != "" {
		if _, err := url.ParseRequestURI(v.url); err != nil {
			return err
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Server) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	urlBytes, ok := proxy["url"]
	if !ok {
		return ErrRequired("url")
	}
	var urlVal string
	if err := yaml.Unmarshal(q(urlBytes), &urlVal); err != nil {
		return err
	}
	v.url = urlVal
	delete(proxy, `url`)

	if err := validateURLTemplate(v.url); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if variablesBytes, ok := proxy["variables"]; ok {
		var variablesVal map[string]*ServerVariable
		if err := yaml.Unmarshal(variablesBytes, &variablesVal); err != nil {
			return err
		}
		v.variables = variablesVal
		delete(proxy, `variables`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *ServerVariable) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if enumBytes, ok := proxy["enum"]; ok {
		var enumVal []string
		if err := yaml.Unmarshal(enumBytes, &enumVal); err != nil {
			return err
		}
		v.enum = enumVal
		delete(proxy, `enum`)
	}

	default_Bytes, ok := proxy["default"]
	if !ok {
		return ErrRequired("default")
	}
	var default_Val string
	if err := yaml.Unmarshal(q(default_Bytes), &default_Val); err != nil {
		return err
	}
	v.default_ = default_Val
	delete(proxy, `default`)

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Components) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if schemasBytes, ok := proxy["schemas"]; ok {
		var schemasVal map[string]*Schema
		if err := yaml.Unmarshal(schemasBytes, &schemasVal); err != nil {
			return err
		}
		v.schemas = schemasVal
		delete(proxy, `schemas`)
	}

	if responsesBytes, ok := proxy["responses"]; ok {
		var responsesVal map[string]*Response
		if err := yaml.Unmarshal(responsesBytes, &responsesVal); err != nil {
			return err
		}
		v.responses = responsesVal
		delete(proxy, `responses`)
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal map[string]*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
		delete(proxy, `parameters`)
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
		delete(proxy, `examples`)
	}

	if requestBodiesBytes, ok := proxy["requestBodies"]; ok {
		var requestBodiesVal map[string]*RequestBody
		if err := yaml.Unmarshal(requestBodiesBytes, &requestBodiesVal); err != nil {
			return err
		}
		v.requestBodies = requestBodiesVal
		delete(proxy, `requestBodies`)
	}

	if headersBytes, ok := proxy["headers"]; ok {
		var headersVal map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headersVal); err != nil {
			return err
		}
		v.headers = headersVal
		delete(proxy, `headers`)
	}

	if securitySchemesBytes, ok := proxy["securitySchemes"]; ok {
		var securitySchemesVal map[string]*SecurityScheme
		if err := yaml.Unmarshal(securitySchemesBytes, &securitySchemesVal); err != nil {
			return err
		}
		v.securitySchemes = securitySchemesVal
		delete(proxy, `securitySchemes`)
	}

	if linksBytes, ok := proxy["links"]; ok {
		var linksVal map[string]*Link
		if err := yaml.Unmarshal(linksBytes, &linksVal); err != nil {
			return err
		}
		v.links = linksVal
		delete(proxy, `links`)
	}

	if callbacksBytes, ok := proxy["callbacks"]; ok {
		var callbacksVal map[string]*Callback
		if err := yaml.Unmarshal(callbacksBytes, &callbacksVal); err != nil {
			return err
		}
		v.callbacks = callbacksVal
		delete(proxy, `callbacks`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Paths) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	paths := map[string]*PathItem{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "/") {
			continue
		}
		var pathsv PathItem
		if err := yaml.Unmarshal(val, &pathsv); err != nil {
			return err
		}
		paths[key] = &pathsv
		delete(proxy, key)
	}
	if len(paths) != 0 {
		v.paths = paths
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *PathItem) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		var summaryVal string
		if err := yaml.Unmarshal(q(summaryBytes), &summaryVal); err != nil {
			return err
		}
		v.summary = summaryVal
		delete(proxy, `summary`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if getBytes, ok := proxy["get"]; ok {
		var getVal Operation
		if err := yaml.Unmarshal(getBytes, &getVal); err != nil {
			return err
		}
		v.get = &getVal
		delete(proxy, `get`)
	}

	if putBytes, ok := proxy["put"]; ok {
		var putVal Operation
		if err := yaml.Unmarshal(putBytes, &putVal); err != nil {
			return err
		}
		v.put = &putVal
		delete(proxy, `put`)
	}

	if postBytes, ok := proxy["post"]; ok {
		var postVal Operation
		if err := yaml.Unmarshal(postBytes, &postVal); err != nil {
			return err
		}
		v.post = &postVal
		delete(proxy, `post`)
	}

	if deleteBytes, ok := proxy["delete"]; ok {
		var deleteVal Operation
		if err := yaml.Unmarshal(deleteBytes, &deleteVal); err != nil {
			return err
		}
		v.delete = &deleteVal
		delete(proxy, `delete`)
	}

	if optionsBytes, ok := proxy["options"]; ok {
		var optionsVal Operation
		if err := yaml.Unmarshal(optionsBytes, &optionsVal); err != nil {
			return err
		}
		v.options = &optionsVal
		delete(proxy, `options`)
	}

	if headBytes, ok := proxy["head"]; ok {
		var headVal Operation
		if err := yaml.Unmarshal(headBytes, &headVal); err != nil {
			return err
		}
		v.head = &headVal
		delete(proxy, `head`)
	}

	if patchBytes, ok := proxy["patch"]; ok {
		var patchVal Operation
		if err := yaml.Unmarshal(patchBytes, &patchVal); err != nil {
			return err
		}
		v.patch = &patchVal
		delete(proxy, `patch`)
	}

	if traceBytes, ok := proxy["trace"]; ok {
		var traceVal Operation
		if err := yaml.Unmarshal(traceBytes, &traceVal); err != nil {
			return err
		}
		v.trace = &traceVal
		delete(proxy, `trace`)
	}

	if serversBytes, ok := proxy["servers"]; ok {
		var serversVal []*Server
		if err := yaml.Unmarshal(serversBytes, &serversVal); err != nil {
			return err
		}
		v.servers = serversVal
		delete(proxy, `servers`)
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal []*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
		delete(proxy, `parameters`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Operation) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if tagsBytes, ok := proxy["tags"]; ok {
		var tagsVal []string
		if err := yaml.Unmarshal(tagsBytes, &tagsVal); err != nil {
			return err
		}
		v.tags = tagsVal
		delete(proxy, `tags`)
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		var summaryVal string
		if err := yaml.Unmarshal(q(summaryBytes), &summaryVal); err != nil {
			return err
		}
		v.summary = summaryVal
		delete(proxy, `summary`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
		delete(proxy, `externalDocs`)
	}

	if operationIDBytes, ok := proxy["operationId"]; ok {
		var operationIDVal string
		if err := yaml.Unmarshal(q(operationIDBytes), &operationIDVal); err != nil {
			return err
		}
		v.operationID = operationIDVal
		delete(proxy, `operationId`)
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal []*Parameter
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
		delete(proxy, `parameters`)
	}

	if requestBodyBytes, ok := proxy["requestBody"]; ok {
		var requestBodyVal RequestBody
		if err := yaml.Unmarshal(requestBodyBytes, &requestBodyVal); err != nil {
			return err
		}
		v.requestBody = &requestBodyVal
		delete(proxy, `requestBody`)
	}

	responsesBytes, ok := proxy["responses"]
	if !ok {
		return ErrRequired("responses")
	}
	var responsesVal Responses
	if err := yaml.Unmarshal(responsesBytes, &responsesVal); err != nil {
		return err
	}
	v.responses = &responsesVal
	delete(proxy, `responses`)

	if callbacksBytes, ok := proxy["callbacks"]; ok {
		var callbacksVal map[string]*Callback
		if err := yaml.Unmarshal(callbacksBytes, &callbacksVal); err != nil {
			return err
		}
		v.callbacks = callbacksVal
		delete(proxy, `callbacks`)
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
		delete(proxy, `deprecated`)
	}

	if securityBytes, ok := proxy["security"]; ok {
		var securityVal []*SecurityRequirement
		if err := yaml.Unmarshal(securityBytes, &securityVal); err != nil {
			return err
		}
		v.security = securityVal
		delete(proxy, `security`)
	}

	if serversBytes, ok := proxy["servers"]; ok {
		var serversVal []*Server
		if err := yaml.Unmarshal(serversBytes, &serversVal); err != nil {
			return err
		}
		v.servers = serversVal
		delete(proxy, `servers`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *ExternalDocumentation) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	urlBytes, ok := proxy["url"]
	if !ok {
		return ErrRequired("url")
	}
	var urlVal string
	if err := yaml.Unmarshal(q(urlBytes), &urlVal); err != nil {
		return err
	}
	v.url = urlVal
	delete(proxy, `url`)

	if _, err := url.ParseRequestURI(v.url); err != nil {
		return err
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Parameter) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return ErrRequired("name")
	}
	var nameVal string
	if err := yaml.Unmarshal(q(nameBytes), &nameVal); err != nil {
		return err
	}
	v.name = nameVal
	delete(proxy, `name`)

	inBytes, ok := proxy["in"]
	if !ok {
		return ErrRequired("in")
	}
	var inVal string
	if err := yaml.Unmarshal(q(inBytes), &inVal); err != nil {
		return err
	}
	v.in = inVal
	delete(proxy, `in`)

	if !isOneOf(v.in, []string{"query", "header", "path", "cookie"}) {
		return errors.New(`"in" field must be one of ["query", "header", "path", "cookie"]`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal bool
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
		delete(proxy, `required`)
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
		delete(proxy, `deprecated`)
	}

	if allowEmptyValueBytes, ok := proxy["allowEmptyValue"]; ok {
		var allowEmptyValueVal bool
		if err := yaml.Unmarshal(allowEmptyValueBytes, &allowEmptyValueVal); err != nil {
			return err
		}
		v.allowEmptyValue = allowEmptyValueVal
		delete(proxy, `allowEmptyValue`)
	}

	if styleBytes, ok := proxy["style"]; ok {
		var styleVal string
		if err := yaml.Unmarshal(q(styleBytes), &styleVal); err != nil {
			return err
		}
		v.style = styleVal
		delete(proxy, `style`)
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		var explodeVal bool
		if err := yaml.Unmarshal(explodeBytes, &explodeVal); err != nil {
			return err
		}
		v.explode = explodeVal
		delete(proxy, `explode`)
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		var allowReservedVal bool
		if err := yaml.Unmarshal(allowReservedBytes, &allowReservedVal); err != nil {
			return err
		}
		v.allowReserved = allowReservedVal
		delete(proxy, `allowReserved`)
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schemaVal Schema
		if err := yaml.Unmarshal(schemaBytes, &schemaVal); err != nil {
			return err
		}
		v.schema = &schemaVal
		delete(proxy, `schema`)
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
		delete(proxy, `example`)
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
		delete(proxy, `examples`)
	}

	if contentBytes, ok := proxy["content"]; ok {
		var contentVal map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
			return err
		}
		v.content = contentVal
		delete(proxy, `content`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *RequestBody) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	contentBytes, ok := proxy["content"]
	if !ok {
		return ErrRequired("content")
	}
	var contentVal map[string]*MediaType
	if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
		return err
	}
	v.content = contentVal
	delete(proxy, `content`)

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal bool
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
		delete(proxy, `required`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *MediaType) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schemaVal Schema
		if err := yaml.Unmarshal(schemaBytes, &schemaVal); err != nil {
			return err
		}
		v.schema = &schemaVal
		delete(proxy, `schema`)
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
		delete(proxy, `example`)
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
		delete(proxy, `examples`)
	}

	if encodingBytes, ok := proxy["encoding"]; ok {
		var encodingVal map[string]*Encoding
		if err := yaml.Unmarshal(encodingBytes, &encodingVal); err != nil {
			return err
		}
		v.encoding = encodingVal
		delete(proxy, `encoding`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Encoding) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if contentTypeBytes, ok := proxy["contentType"]; ok {
		var contentTypeVal string
		if err := yaml.Unmarshal(q(contentTypeBytes), &contentTypeVal); err != nil {
			return err
		}
		v.contentType = contentTypeVal
		delete(proxy, `contentType`)
	}

	if headersBytes, ok := proxy["headers"]; ok {
		var headersVal map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headersVal); err != nil {
			return err
		}
		v.headers = headersVal
		delete(proxy, `headers`)
	}

	if styleBytes, ok := proxy["style"]; ok {
		var styleVal string
		if err := yaml.Unmarshal(q(styleBytes), &styleVal); err != nil {
			return err
		}
		v.style = styleVal
		delete(proxy, `style`)
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		var explodeVal bool
		if err := yaml.Unmarshal(explodeBytes, &explodeVal); err != nil {
			return err
		}
		v.explode = explodeVal
		delete(proxy, `explode`)
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		var allowReservedVal bool
		if err := yaml.Unmarshal(allowReservedBytes, &allowReservedVal); err != nil {
			return err
		}
		v.allowReserved = allowReservedVal
		delete(proxy, `allowReserved`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Responses) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	responses := map[string]*Response{}
	for key, val := range proxy {
		responsesRegexp := regexp.MustCompile(`^[1-5]([0-9][0-9]|XX)|default$`)
		if !responsesRegexp.MatchString(key) {
			continue
		}
		var responsesv Response
		if err := yaml.Unmarshal(val, &responsesv); err != nil {
			return err
		}
		responses[key] = &responsesv
		delete(proxy, key)
	}
	if len(responses) != 0 {
		v.responses = responses
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Response) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	descriptionBytes, ok := proxy["description"]
	if !ok {
		return ErrRequired("description")
	}
	var descriptionVal string
	if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
		return err
	}
	v.description = descriptionVal
	delete(proxy, `description`)

	if headersBytes, ok := proxy["headers"]; ok {
		var headersVal map[string]*Header
		if err := yaml.Unmarshal(headersBytes, &headersVal); err != nil {
			return err
		}
		v.headers = headersVal
		delete(proxy, `headers`)
	}

	if contentBytes, ok := proxy["content"]; ok {
		var contentVal map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
			return err
		}
		v.content = contentVal
		delete(proxy, `content`)
	}

	if linksBytes, ok := proxy["links"]; ok {
		var linksVal map[string]*Link
		if err := yaml.Unmarshal(linksBytes, &linksVal); err != nil {
			return err
		}
		v.links = linksVal
		delete(proxy, `links`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Callback) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}
	callback := map[string]*PathItem{}
	for key, val := range proxy {
		if !IsRuntimeExpr(key) {
			continue
		}
		var callbackv PathItem
		if err := yaml.Unmarshal(val, &callbackv); err != nil {
			return err
		}
		callback[key] = &callbackv
		delete(proxy, key)
	}
	if len(callback) != 0 {
		v.callback = callback
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Example) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	if summaryBytes, ok := proxy["summary"]; ok {
		var summaryVal string
		if err := yaml.Unmarshal(q(summaryBytes), &summaryVal); err != nil {
			return err
		}
		v.summary = summaryVal
		delete(proxy, `summary`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if valueBytes, ok := proxy["value"]; ok {
		var valueVal interface{}
		if err := yaml.Unmarshal(valueBytes, &valueVal); err != nil {
			return err
		}
		v.value = valueVal
		delete(proxy, `value`)
	}

	if externalValueBytes, ok := proxy["externalValue"]; ok {
		var externalValueVal string
		if err := yaml.Unmarshal(q(externalValueBytes), &externalValueVal); err != nil {
			return err
		}
		v.externalValue = externalValueVal
		delete(proxy, `externalValue`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Link) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	if operationRefBytes, ok := proxy["operationRef"]; ok {
		var operationRefVal string
		if err := yaml.Unmarshal(q(operationRefBytes), &operationRefVal); err != nil {
			return err
		}
		v.operationRef = operationRefVal
		delete(proxy, `operationRef`)
	}

	if operationIDBytes, ok := proxy["operationId"]; ok {
		var operationIDVal string
		if err := yaml.Unmarshal(q(operationIDBytes), &operationIDVal); err != nil {
			return err
		}
		v.operationID = operationIDVal
		delete(proxy, `operationId`)
	}

	if parametersBytes, ok := proxy["parameters"]; ok {
		var parametersVal map[string]interface{}
		if err := yaml.Unmarshal(parametersBytes, &parametersVal); err != nil {
			return err
		}
		v.parameters = parametersVal
		delete(proxy, `parameters`)
	}

	if requestBodyBytes, ok := proxy["requestBody"]; ok {
		var requestBodyVal interface{}
		if err := yaml.Unmarshal(requestBodyBytes, &requestBodyVal); err != nil {
			return err
		}
		v.requestBody = requestBodyVal
		delete(proxy, `requestBody`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if serverBytes, ok := proxy["server"]; ok {
		var serverVal Server
		if err := yaml.Unmarshal(serverBytes, &serverVal); err != nil {
			return err
		}
		v.server = &serverVal
		delete(proxy, `server`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Header) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal bool
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
		delete(proxy, `required`)
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
		delete(proxy, `deprecated`)
	}

	if allowEmptyValueBytes, ok := proxy["allowEmptyValue"]; ok {
		var allowEmptyValueVal bool
		if err := yaml.Unmarshal(allowEmptyValueBytes, &allowEmptyValueVal); err != nil {
			return err
		}
		v.allowEmptyValue = allowEmptyValueVal
		delete(proxy, `allowEmptyValue`)
	}

	if styleBytes, ok := proxy["style"]; ok {
		var styleVal string
		if err := yaml.Unmarshal(q(styleBytes), &styleVal); err != nil {
			return err
		}
		v.style = styleVal
		delete(proxy, `style`)
	}

	if explodeBytes, ok := proxy["explode"]; ok {
		var explodeVal bool
		if err := yaml.Unmarshal(explodeBytes, &explodeVal); err != nil {
			return err
		}
		v.explode = explodeVal
		delete(proxy, `explode`)
	}

	if allowReservedBytes, ok := proxy["allowReserved"]; ok {
		var allowReservedVal bool
		if err := yaml.Unmarshal(allowReservedBytes, &allowReservedVal); err != nil {
			return err
		}
		v.allowReserved = allowReservedVal
		delete(proxy, `allowReserved`)
	}

	if schemaBytes, ok := proxy["schema"]; ok {
		var schemaVal Schema
		if err := yaml.Unmarshal(schemaBytes, &schemaVal); err != nil {
			return err
		}
		v.schema = &schemaVal
		delete(proxy, `schema`)
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
		delete(proxy, `example`)
	}

	if examplesBytes, ok := proxy["examples"]; ok {
		var examplesVal map[string]*Example
		if err := yaml.Unmarshal(examplesBytes, &examplesVal); err != nil {
			return err
		}
		v.examples = examplesVal
		delete(proxy, `examples`)
	}

	if contentBytes, ok := proxy["content"]; ok {
		var contentVal map[string]*MediaType
		if err := yaml.Unmarshal(contentBytes, &contentVal); err != nil {
			return err
		}
		v.content = contentVal
		delete(proxy, `content`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Tag) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	nameBytes, ok := proxy["name"]
	if !ok {
		return ErrRequired("name")
	}
	var nameVal string
	if err := yaml.Unmarshal(q(nameBytes), &nameVal); err != nil {
		return err
	}
	v.name = nameVal
	delete(proxy, `name`)

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
		delete(proxy, `externalDocs`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Schema) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	if titleBytes, ok := proxy["title"]; ok {
		var titleVal string
		if err := yaml.Unmarshal(q(titleBytes), &titleVal); err != nil {
			return err
		}
		v.title = titleVal
		delete(proxy, `title`)
	}

	if multipleOfBytes, ok := proxy["multipleOf"]; ok {
		var multipleOfVal int
		if err := yaml.Unmarshal(multipleOfBytes, &multipleOfVal); err != nil {
			return err
		}
		v.multipleOf = multipleOfVal
		delete(proxy, `multipleOf`)
	}

	if maximumBytes, ok := proxy["maximum"]; ok {
		var maximumVal int
		if err := yaml.Unmarshal(maximumBytes, &maximumVal); err != nil {
			return err
		}
		v.maximum = maximumVal
		delete(proxy, `maximum`)
	}

	if exclusiveMaximumBytes, ok := proxy["exclusiveMaximum"]; ok {
		var exclusiveMaximumVal bool
		if err := yaml.Unmarshal(exclusiveMaximumBytes, &exclusiveMaximumVal); err != nil {
			return err
		}
		v.exclusiveMaximum = exclusiveMaximumVal
		delete(proxy, `exclusiveMaximum`)
	}

	if minimumBytes, ok := proxy["minimum"]; ok {
		var minimumVal int
		if err := yaml.Unmarshal(minimumBytes, &minimumVal); err != nil {
			return err
		}
		v.minimum = minimumVal
		delete(proxy, `minimum`)
	}

	if exclusiveMinimumBytes, ok := proxy["exclusiveMinimum"]; ok {
		var exclusiveMinimumVal bool
		if err := yaml.Unmarshal(exclusiveMinimumBytes, &exclusiveMinimumVal); err != nil {
			return err
		}
		v.exclusiveMinimum = exclusiveMinimumVal
		delete(proxy, `exclusiveMinimum`)
	}

	if maxLengthBytes, ok := proxy["maxLength"]; ok {
		var maxLengthVal int
		if err := yaml.Unmarshal(maxLengthBytes, &maxLengthVal); err != nil {
			return err
		}
		v.maxLength = maxLengthVal
		delete(proxy, `maxLength`)
	}

	if minLengthBytes, ok := proxy["minLength"]; ok {
		var minLengthVal int
		if err := yaml.Unmarshal(minLengthBytes, &minLengthVal); err != nil {
			return err
		}
		v.minLength = minLengthVal
		delete(proxy, `minLength`)
	}

	if patternBytes, ok := proxy["pattern"]; ok {
		var patternVal string
		if err := yaml.Unmarshal(q(patternBytes), &patternVal); err != nil {
			return err
		}
		v.pattern = patternVal
		delete(proxy, `pattern`)
	}

	if maxItemsBytes, ok := proxy["maxItems"]; ok {
		var maxItemsVal int
		if err := yaml.Unmarshal(maxItemsBytes, &maxItemsVal); err != nil {
			return err
		}
		v.maxItems = maxItemsVal
		delete(proxy, `maxItems`)
	}

	if minItemsBytes, ok := proxy["minItems"]; ok {
		var minItemsVal int
		if err := yaml.Unmarshal(minItemsBytes, &minItemsVal); err != nil {
			return err
		}
		v.minItems = minItemsVal
		delete(proxy, `minItems`)
	}

	if maxPropertiesBytes, ok := proxy["maxProperties"]; ok {
		var maxPropertiesVal int
		if err := yaml.Unmarshal(maxPropertiesBytes, &maxPropertiesVal); err != nil {
			return err
		}
		v.maxProperties = maxPropertiesVal
		delete(proxy, `maxProperties`)
	}

	if minPropertiesBytes, ok := proxy["minProperties"]; ok {
		var minPropertiesVal int
		if err := yaml.Unmarshal(minPropertiesBytes, &minPropertiesVal); err != nil {
			return err
		}
		v.minProperties = minPropertiesVal
		delete(proxy, `minProperties`)
	}

	if requiredBytes, ok := proxy["required"]; ok {
		var requiredVal []string
		if err := yaml.Unmarshal(requiredBytes, &requiredVal); err != nil {
			return err
		}
		v.required = requiredVal
		delete(proxy, `required`)
	}

	if enumBytes, ok := proxy["enum"]; ok {
		var enumVal []string
		if err := yaml.Unmarshal(enumBytes, &enumVal); err != nil {
			return err
		}
		v.enum = enumVal
		delete(proxy, `enum`)
	}

	if type_Bytes, ok := proxy["type"]; ok {
		var type_Val string
		if err := yaml.Unmarshal(q(type_Bytes), &type_Val); err != nil {
			return err
		}
		v.type_ = type_Val
		delete(proxy, `type`)
	}

	if allOfBytes, ok := proxy["allOf"]; ok {
		var allOfVal []*Schema
		if err := yaml.Unmarshal(allOfBytes, &allOfVal); err != nil {
			return err
		}
		v.allOf = allOfVal
		delete(proxy, `allOf`)
	}

	if oneOfBytes, ok := proxy["oneOf"]; ok {
		var oneOfVal []*Schema
		if err := yaml.Unmarshal(oneOfBytes, &oneOfVal); err != nil {
			return err
		}
		v.oneOf = oneOfVal
		delete(proxy, `oneOf`)
	}

	if anyOfBytes, ok := proxy["anyOf"]; ok {
		var anyOfVal []*Schema
		if err := yaml.Unmarshal(anyOfBytes, &anyOfVal); err != nil {
			return err
		}
		v.anyOf = anyOfVal
		delete(proxy, `anyOf`)
	}

	if notBytes, ok := proxy["not"]; ok {
		var notVal Schema
		if err := yaml.Unmarshal(notBytes, &notVal); err != nil {
			return err
		}
		v.not = &notVal
		delete(proxy, `not`)
	}

	if itemsBytes, ok := proxy["items"]; ok {
		var itemsVal Schema
		if err := yaml.Unmarshal(itemsBytes, &itemsVal); err != nil {
			return err
		}
		v.items = &itemsVal
		delete(proxy, `items`)
	}

	if propertiesBytes, ok := proxy["properties"]; ok {
		var propertiesVal map[string]*Schema
		if err := yaml.Unmarshal(propertiesBytes, &propertiesVal); err != nil {
			return err
		}
		v.properties = propertiesVal
		delete(proxy, `properties`)
	}

	if additionalPropertiesBytes, ok := proxy["additionalProperties"]; ok {
		var additionalPropertiesVal Schema
		if err := yaml.Unmarshal(additionalPropertiesBytes, &additionalPropertiesVal); err != nil {
			return err
		}
		v.additionalProperties = &additionalPropertiesVal
		delete(proxy, `additionalProperties`)
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if formatBytes, ok := proxy["format"]; ok {
		var formatVal string
		if err := yaml.Unmarshal(q(formatBytes), &formatVal); err != nil {
			return err
		}
		v.format = formatVal
		delete(proxy, `format`)
	}

	if default_Bytes, ok := proxy["default"]; ok {
		var default_Val string
		if err := yaml.Unmarshal(q(default_Bytes), &default_Val); err != nil {
			return err
		}
		v.default_ = default_Val
		delete(proxy, `default`)
	}

	if nullableBytes, ok := proxy["nullable"]; ok {
		var nullableVal bool
		if err := yaml.Unmarshal(nullableBytes, &nullableVal); err != nil {
			return err
		}
		v.nullable = nullableVal
		delete(proxy, `nullable`)
	}

	if discriminatorBytes, ok := proxy["discriminator"]; ok {
		var discriminatorVal Discriminator
		if err := yaml.Unmarshal(discriminatorBytes, &discriminatorVal); err != nil {
			return err
		}
		v.discriminator = &discriminatorVal
		delete(proxy, `discriminator`)
	}

	if readOnlyBytes, ok := proxy["readOnly"]; ok {
		var readOnlyVal bool
		if err := yaml.Unmarshal(readOnlyBytes, &readOnlyVal); err != nil {
			return err
		}
		v.readOnly = readOnlyVal
		delete(proxy, `readOnly`)
	}

	if writeOnlyBytes, ok := proxy["writeOnly"]; ok {
		var writeOnlyVal bool
		if err := yaml.Unmarshal(writeOnlyBytes, &writeOnlyVal); err != nil {
			return err
		}
		v.writeOnly = writeOnlyVal
		delete(proxy, `writeOnly`)
	}

	if xmlBytes, ok := proxy["xml"]; ok {
		var xmlVal XML
		if err := yaml.Unmarshal(xmlBytes, &xmlVal); err != nil {
			return err
		}
		v.xml = &xmlVal
		delete(proxy, `xml`)
	}

	if externalDocsBytes, ok := proxy["externalDocs"]; ok {
		var externalDocsVal ExternalDocumentation
		if err := yaml.Unmarshal(externalDocsBytes, &externalDocsVal); err != nil {
			return err
		}
		v.externalDocs = &externalDocsVal
		delete(proxy, `externalDocs`)
	}

	if exampleBytes, ok := proxy["example"]; ok {
		var exampleVal interface{}
		if err := yaml.Unmarshal(exampleBytes, &exampleVal); err != nil {
			return err
		}
		v.example = exampleVal
		delete(proxy, `example`)
	}

	if deprecatedBytes, ok := proxy["deprecated"]; ok {
		var deprecatedVal bool
		if err := yaml.Unmarshal(deprecatedBytes, &deprecatedVal); err != nil {
			return err
		}
		v.deprecated = deprecatedVal
		delete(proxy, `deprecated`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *Discriminator) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if propertyNameBytes, ok := proxy["propertyName"]; ok {
		var propertyNameVal string
		if err := yaml.Unmarshal(q(propertyNameBytes), &propertyNameVal); err != nil {
			return err
		}
		v.propertyName = propertyNameVal
		delete(proxy, `propertyName`)
	}

	if mappingBytes, ok := proxy["mapping"]; ok {
		var mappingVal map[string]string
		if err := yaml.Unmarshal(mappingBytes, &mappingVal); err != nil {
			return err
		}
		v.mapping = mappingVal
		delete(proxy, `mapping`)
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *XML) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if nameBytes, ok := proxy["name"]; ok {
		var nameVal string
		if err := yaml.Unmarshal(q(nameBytes), &nameVal); err != nil {
			return err
		}
		v.name = nameVal
		delete(proxy, `name`)
	}

	if namespaceBytes, ok := proxy["namespace"]; ok {
		var namespaceVal string
		if err := yaml.Unmarshal(q(namespaceBytes), &namespaceVal); err != nil {
			return err
		}
		v.namespace = namespaceVal
		delete(proxy, `namespace`)
	}

	if prefixBytes, ok := proxy["prefix"]; ok {
		var prefixVal string
		if err := yaml.Unmarshal(q(prefixBytes), &prefixVal); err != nil {
			return err
		}
		v.prefix = prefixVal
		delete(proxy, `prefix`)
	}

	if attributeBytes, ok := proxy["attribute"]; ok {
		var attributeVal bool
		if err := yaml.Unmarshal(attributeBytes, &attributeVal); err != nil {
			return err
		}
		v.attribute = attributeVal
		delete(proxy, `attribute`)
	}

	if wrappedBytes, ok := proxy["wrapped"]; ok {
		var wrappedVal bool
		if err := yaml.Unmarshal(wrappedBytes, &wrappedVal); err != nil {
			return err
		}
		v.wrapped = wrappedVal
		delete(proxy, `wrapped`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *SecurityScheme) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	if referenceBytes, ok := proxy["$ref"]; ok {
		var referenceVal string
		if err := yaml.Unmarshal(q(referenceBytes), &referenceVal); err != nil {
			return err
		}
		v.reference = referenceVal
		delete(proxy, "$ref")
		return nil
	}

	if type_Bytes, ok := proxy["type"]; ok {
		var type_Val string
		if err := yaml.Unmarshal(q(type_Bytes), &type_Val); err != nil {
			return err
		}
		v.type_ = type_Val
		delete(proxy, `type`)
	}

	if v.type_ != "" {
		if !isOneOf(v.type_, []string{"apiKey", "http", "oauth2", "openIdConnect"}) {
			return errors.New(`"type" field must be one of ["apiKey", "http", "oauth2", "openIdConnect"]`)
		}
	}

	if descriptionBytes, ok := proxy["description"]; ok {
		var descriptionVal string
		if err := yaml.Unmarshal(q(descriptionBytes), &descriptionVal); err != nil {
			return err
		}
		v.description = descriptionVal
		delete(proxy, `description`)
	}

	if nameBytes, ok := proxy["name"]; ok {
		var nameVal string
		if err := yaml.Unmarshal(q(nameBytes), &nameVal); err != nil {
			return err
		}
		v.name = nameVal
		delete(proxy, `name`)
	}

	if inBytes, ok := proxy["in"]; ok {
		var inVal string
		if err := yaml.Unmarshal(q(inBytes), &inVal); err != nil {
			return err
		}
		v.in = inVal
		delete(proxy, `in`)
	}

	if v.in != "" {
		if !isOneOf(v.in, []string{"query", "header", "cookie"}) {
			return errors.New(`"in" field must be one of ["query", "header", "cookie"]`)
		}
	}

	if schemeBytes, ok := proxy["scheme"]; ok {
		var schemeVal string
		if err := yaml.Unmarshal(q(schemeBytes), &schemeVal); err != nil {
			return err
		}
		v.scheme = schemeVal
		delete(proxy, `scheme`)
	}

	if bearerFormatBytes, ok := proxy["bearerFormat"]; ok {
		var bearerFormatVal string
		if err := yaml.Unmarshal(q(bearerFormatBytes), &bearerFormatVal); err != nil {
			return err
		}
		v.bearerFormat = bearerFormatVal
		delete(proxy, `bearerFormat`)
	}

	if flowsBytes, ok := proxy["flows"]; ok {
		var flowsVal OAuthFlows
		if err := yaml.Unmarshal(flowsBytes, &flowsVal); err != nil {
			return err
		}
		v.flows = &flowsVal
		delete(proxy, `flows`)
	}

	if openIDConnectURLBytes, ok := proxy["openIdConnectUrl"]; ok {
		var openIDConnectURLVal string
		if err := yaml.Unmarshal(q(openIDConnectURLBytes), &openIDConnectURLVal); err != nil {
			return err
		}
		v.openIDConnectURL = openIDConnectURLVal
		delete(proxy, `openIdConnectUrl`)
	}

	if v.openIDConnectURL != "" {
		if _, err := url.ParseRequestURI(v.openIDConnectURL); err != nil {
			return err
		}
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *OAuthFlows) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if implicitBytes, ok := proxy["implicit"]; ok {
		var implicitVal OAuthFlow
		if err := yaml.Unmarshal(implicitBytes, &implicitVal); err != nil {
			return err
		}
		v.implicit = &implicitVal
		delete(proxy, `implicit`)
	}

	if passwordBytes, ok := proxy["password"]; ok {
		var passwordVal OAuthFlow
		if err := yaml.Unmarshal(passwordBytes, &passwordVal); err != nil {
			return err
		}
		v.password = &passwordVal
		delete(proxy, `password`)
	}

	if clientCredentialsBytes, ok := proxy["clientCredentials"]; ok {
		var clientCredentialsVal OAuthFlow
		if err := yaml.Unmarshal(clientCredentialsBytes, &clientCredentialsVal); err != nil {
			return err
		}
		v.clientCredentials = &clientCredentialsVal
		delete(proxy, `clientCredentials`)
	}

	if authorizationCodeBytes, ok := proxy["authorizationCode"]; ok {
		var authorizationCodeVal OAuthFlow
		if err := yaml.Unmarshal(authorizationCodeBytes, &authorizationCodeVal); err != nil {
			return err
		}
		v.authorizationCode = &authorizationCodeVal
		delete(proxy, `authorizationCode`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *OAuthFlow) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}

	if authorizationURLBytes, ok := proxy["authorizationUrl"]; ok {
		var authorizationURLVal string
		if err := yaml.Unmarshal(q(authorizationURLBytes), &authorizationURLVal); err != nil {
			return err
		}
		v.authorizationURL = authorizationURLVal
		delete(proxy, `authorizationUrl`)
	}

	if v.authorizationURL != "" {
		if _, err := url.ParseRequestURI(v.authorizationURL); err != nil {
			return err
		}
	}

	if tokenURLBytes, ok := proxy["tokenUrl"]; ok {
		var tokenURLVal string
		if err := yaml.Unmarshal(q(tokenURLBytes), &tokenURLVal); err != nil {
			return err
		}
		v.tokenURL = tokenURLVal
		delete(proxy, `tokenUrl`)
	}

	if v.tokenURL != "" {
		if _, err := url.ParseRequestURI(v.tokenURL); err != nil {
			return err
		}
	}

	if refreshURLBytes, ok := proxy["refreshUrl"]; ok {
		var refreshURLVal string
		if err := yaml.Unmarshal(q(refreshURLBytes), &refreshURLVal); err != nil {
			return err
		}
		v.refreshURL = refreshURLVal
		delete(proxy, `refreshUrl`)
	}

	if v.refreshURL != "" {
		if _, err := url.ParseRequestURI(v.refreshURL); err != nil {
			return err
		}
	}

	if scopesBytes, ok := proxy["scopes"]; ok {
		var scopesVal map[string]string
		if err := yaml.Unmarshal(scopesBytes, &scopesVal); err != nil {
			return err
		}
		v.scopes = scopesVal
		delete(proxy, `scopes`)
	}
	extension := map[string]interface{}{}
	for key, val := range proxy {
		if !strings.HasPrefix(key, "x-") {
			continue
		}
		var extensionv interface{}
		if err := yaml.Unmarshal(val, &extensionv); err != nil {
			return err
		}
		extension[key] = extensionv
		delete(proxy, key)
	}
	if len(extension) != 0 {
		v.extension = extension
	}
	if len(proxy) != 0 {
		for k := range proxy {
			return ErrUnknownKey(k)
		}
	}
	return nil
}

func (v *SecurityRequirement) UnmarshalYAML(b []byte) error {
	var proxy map[string]raw
	if err := yaml.Unmarshal(b, &proxy); err != nil {
		return err
	}
	securityRequirement := map[string][]string{}
	for key, val := range proxy {
		var securityRequirementv []string
		if err := yaml.Unmarshal(val, &securityRequirementv); err != nil {
			return err
		}
		securityRequirement[key] = securityRequirementv
		delete(proxy, key)
	}
	if len(securityRequirement) != 0 {
		v.securityRequirement = securityRequirement
	}
	return nil
}
